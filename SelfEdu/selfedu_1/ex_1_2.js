/* jshint globalstrict: true */
'use strict';

/* В любом объекте можно создавать специальные свойства, которые будут срабатывать в момент присвоения 
(set) и чтения (get) данных из объекта. Они определяются по следующему синтаксису:

set <имя метода>([параметры]) {…} – свойство для записи значений в объект;
get <имя метода>([параметры]) {…} – свойство для чтения значений из объекта.
 */


let geom = {
  name: "фигура",
  sp: {x: 0, y: 0},
  ep: {x: 100, y: 20},
  get nameGeom() {return this.name; },
  set nameGeom(name) {this.name = name; },
};


let rect = {
  draw() {
            console.log("Рисование прямоугольника: " +
                     this.sp.x+","+this.sp.y+","+this.ep.x+","+this.ep.y);
  }
};

rect.__proto__ = geom;

// И, далее, можно с ними работать, следующим образом:

console.log(rect.nameGeom);      // чтение свойства
rect.nameGeom = "Прямоугольник"; // запись свойства
console.log(rect.nameGeom);


/* на какой из двух объектов (geom или rect) ссылается this при вызове сеттера:

rect.nameGeom = "Прямоугольник";

Как мы с вами говорили на предыдущих занятиях по JavaScript, указатель this является динамическим и определяется контекстом вызова метода. 
В данном случае контекст – это объект rect и именно на него ссылается this при вызове сеттера из базового объекта geom 
В результате, состояние базового объекта не меняется, а в rect добавляется свойство name:*/


console.log(rect.nameGeom);     // Прямоугольник
console.log(geom.nameGeom);     // Фигура


/* Или, эту проверку можно визуализировать еще лучше, если воспользоваться специальным методом:

obj.hasOwnProperty(key)

который возвращает true, если ключ (key) принадлежит объекту obj и false – в противном случае */

for(let prop in rect)
         if( rect.hasOwnProperty(prop) ) 
                   console.log(prop + ": " + rect[prop]);

// То есть, свойство name действительно было создано в дочернем объекте rect.    






