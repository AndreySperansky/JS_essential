/* jshint globalstrict: true */
'use strict';

let geom = {
         name: "фигура",
         sp: {x: 0, y: 0},
         ep: {x: 100, y: 20}
};

//Также мы говорили, что для перебора всех свойств и методов объекта используется цикл for in:

// for(let key in geom) {
//   console.log(key+": "+geom[key]);
// }

/* А дальше сделаем следующий, новый для нас ход: объявим новый объект, который бы расширял функционал уже существующего geom. 
Это можно сделать с помощью специального свойства __proto__ которое есть у каждого объекта JavaScript. 
Именно через него устанавливается связь с базовым (расширяемым) объектом */

let rect = {
  draw() {
            console.log("Рисование прямоугольника: " +
                     this.sp.x+","+this.sp.y+","+this.ep.x+","+this.ep.y);
  }
};

rect.__proto__ = geom;


for(let key in rect) {
  console.log(key+": "+rect[key]);
}


// И эту цепочку можно продолжить, например, добавив вот такой объект:

let info = {
         getInfo() {
                   console.log(this.name);
         },
         __proto__: rect              // rect.__proto__ = info   если вне объекта
};
 
info.getInfo();     // фигура

// Теперь у нас info наследуется от rect, а rect – от geom:

// for(let key in info) {
//   console.log(key+": "+info[key]);
// }



/* Разумеется, когда мы используем свойство __proto__, то ему можно присваивать либо другой объект, либо значение null. 
Все остальные типы будут попросту игнорироваться. Также из этой схемы видно, что множественное наследование реализовать не получится, 
т.к. свойство __proto__ ссылается лишь на один определенный объект (либо ни на одного при значении null). */

/* Далее, из объекта, указанного в прототипе можно выполнять только чтение свойств и методов. 
Например, если в объекте rect создать свойство name: */

rect.name = "прямоугольник";

console.log(geom.name);          // фигура



